import cv2
import numpy as np
import os

# Chemin du dossier contenant les images
NAAL_GOMYCODE = "C:/Users/toshiba/OneDrive/Bureau/NAAL_GOMYCODE/IMAGE_PANNEAU"

# V√©rifie si le dossier existe
if not os.path.exists(NAAL_GOMYCODE):
    print(f"Erreur : Le dossier '{NAAL_GOMYCODE}' n'existe pas.")
else:
    # Liste tous les fichiers du dossier
    fichiers = os.listdir(NAAL_GOMYCODE)
    
    # Filtrer les fichiers pour ne garder que les images .jpeg, png et jpg
    filesExtensions = '.png', '.jpg', '.jpeg'
    images = [f for f in fichiers if f.lower().endswith(filesExtensions)]

    if not images:
        print("Aucune image trouv√©e dans le dossier.")
    else:
        # Parcourir et afficher chaque image
        for image_nom in images:
            # Construire le chemin complet de l'image
            chemin_image = os.path.join(NAAL_GOMYCODE, image_nom)

            # Charger l'image
            image = cv2.imread(chemin_image)

            # V√©rifie si l'image a √©t√© charg√©e correctement
            if image is None:
                print(f"Impossible de charger l'image : {image_nom}")
                continue

            # Afficher l'image
            cv2.imshow(f"Image : {image_nom}", image)

            # Attendre qu'une touche soit press√©e pour passer √† l'image suivante
            print(f"Affichage de : {image_nom}. Appuyez sur une touche pour continuer...")
            cv2.waitKey(1000)
            cv2.destroyAllWindows()

            # Fenetre apres l'affichage
            cv2.destroyAllWindows()

        print("Toutes les images ont √©t√© affich√©es.")
# 1. Convertir en niveaux de gris
        gris = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

            # üîπ 2. Appliquer un flou gaussien pour r√©duire le bruit
        flou = cv2.GaussianBlur(gris, (5, 5), 0)

            # üîπ 3. D√©tecter les contours avec l‚Äôalgorithme de Canny
        contours = cv2.Canny(flou, 50, 150)

            # üîπ 4. Afficher les diff√©rentes transformations
        cv2.imshow(f"Original - {image_nom}", image)
        cv2.imshow(f"Niveaux de gris - {image_nom}", gris)
        cv2.imshow(f"Flou - {image_nom}", flou)
        cv2.imshow(f"Contours - {image_nom}", contours)

        print(f"Affichage de {image_nom}. Appuyez sur une touche pour continuer...")
        cv2.waitKey(1000)  # Affichage pendant 1 seconde
        cv2.destroyAllWindows()

        print("Toutes les images ont √©t√© trait√©es.")
       # üîπ 1. Convertir en niveaux de gris
        gris = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

            # üîπ 2. Appliquer un flou gaussien
        flou = cv2.GaussianBlur(gris, (5, 5), 0)

            # üîπ 3. D√©tection des contours
        contours = cv2.Canny(flou, 50, 150)

            # üîπ 4. Trouver et analyser les contours
        contours_detect√©s, _ = cv2.findContours(contours, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

        for cnt in contours_detect√©s:
                # Approximer la forme du contour
                epsilon = 0.02 * cv2.arcLength(cnt, True)
                approx = cv2.approxPolyDP(cnt, epsilon, True)

                # Dessiner le contour sur l'image originale
                cv2.drawContours(image, [approx], -1, (0, 255, 0), 2)

                # Identifier la forme en fonction du nombre de sommets
                if len(approx) == 3:
                    forme = "Triangle"
                elif len(approx) == 4:
                    forme = "Rectangle"
                elif len(approx) > 8:  # Beaucoup de sommets ‚âà cercle
                    forme = "Cercle"
                else:
                    forme = "Autre"

                # Afficher le nom de la forme sur l'image
                x, y, _, _ = cv2.boundingRect(approx)
                cv2.putText(image, forme, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)

            # üîπ 5. Afficher les r√©sultats
        cv2.imshow(f"Formes d√©tect√©es - {image_nom}", image)
        cv2.waitKey(1000)
        cv2.destroyAllWindows()
    print("D√©tection des formes termin√©e.")

 # üîπ 1. Convertir en HSV pour d√©tecter le rouge
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

            # üîπ 2. D√©finir les plages de rouge
    rouge_bas1 = np.array([0, 70, 50])  # Premi√®re plage
    rouge_haut1 = np.array([10, 255, 255])
    rouge_bas2 = np.array([170, 70, 50])  # Seconde plage
    rouge_haut2 = np.array([180, 255, 255])

            # üîπ 3. Masquer les pixels rouges
    masque1 = cv2.inRange(hsv, rouge_bas1, rouge_haut1)
    masque2 = cv2.inRange(hsv, rouge_bas2, rouge_haut2)
    masque_rouge = masque1 + masque2

            # üîπ 4. D√©tection des contours
    contours, _ = cv2.findContours(masque_rouge, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    for cnt in contours:
                epsilon = 0.02 * cv2.arcLength(cnt, True)
                approx = cv2.approxPolyDP(cnt, epsilon, True)
                x, y, w, h = cv2.boundingRect(approx)

                # Si la forme est un triangle
                if len(approx) == 3:
                    cv2.drawContours(image, [approx], -1, (0, 255, 0), 2)
                    cv2.putText(image, "‚ö†Ô∏è Panneau Danger", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)

            # üîπ 5. Afficher le r√©sultat
    cv2.imshow(f"Panneaux de danger d√©tect√©s - {image_nom}", image)
    cv2.waitKey(1000)
    cv2.destroyAllWindows()
    print("D√©tection des panneaux de danger termin√©e.")

def trouver_cercles(masque, couleur):
    contours, _ = cv2.findContours(masque, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    for cnt in contours:
        approx = cv2.approxPolyDP(cnt, 0.02 * cv2.arcLength(cnt, True), True)
        x, y, w, h = cv2.boundingRect(approx)

        if len(approx) > 8:  # Approximativement un cercle
            cv2.drawContours(image, [approx], -1, couleur, 2)
            return (x, y)  # Retourne les coordonn√©es du cercle

    return None  # Si aucun cercle trouv√©, retourne None
# Convertir l'image en HSV
hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

# D√©finir les plages de couleur
rouge_bas1 = np.array([0, 100, 100])
rouge_haut1 = np.array([10, 255, 255])
rouge_bas2 = np.array([160, 100, 100])
rouge_haut2 = np.array([180, 255, 255])

vert_bas = np.array([40, 50, 50])
vert_haut = np.array([90, 255, 255])

orange_bas = np.array([10, 100, 100])
orange_haut = np.array([30, 255, 255])

# Cr√©er les masques pour les feux tricolores
masque_rouge = cv2.inRange(hsv, rouge_bas1, rouge_haut1) + cv2.inRange(hsv, rouge_bas2, rouge_haut2)
masque_vert = cv2.inRange(hsv, vert_bas, vert_haut)
masque_orange = cv2.inRange(hsv, orange_bas, orange_haut)

# D√©tection des feux
feu_rouge = trouver_cercles(masque_rouge, (0, 0, 255))
feu_orange = trouver_cercles(masque_orange, (0, 165, 255))
feu_vert = trouver_cercles(masque_vert, (0, 255, 0))

# V√©rification et affichage dans la console
if feu_rouge:
    print("üî¥ Feu Rouge d√©tect√© aux coordonn√©es :", feu_rouge)
    cv2.putText(image, "üî¥ Feu Rouge", feu_rouge, cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)

if feu_orange:
    print("üü† Feu Orange d√©tect√© aux coordonn√©es :", feu_orange)
    cv2.putText(image, "üü† Feu Orange", feu_orange, cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 165, 255), 2)

if feu_vert:
    print("üü¢ Feu Vert d√©tect√© aux coordonn√©es :", feu_vert)
    cv2.putText(image, "üü¢ Feu Vert", feu_vert, cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)

# Affichage du r√©sultat
cv2.imshow(f"Feux tricolores d√©tect√©s - {image_nom}", image)
cv2.waitKey(1000)
cv2.destroyAllWindows()


#  APPRENTISSAGE PROFOND

# Supposons que 'x, y, w, h' sont les coordonn√©es du panneau d√©tect√©
roi = image[y:y+h, x:x+w]  # Extraire la zone du panneau
roi = cv2.resize(roi, (64, 64))  # Adapter √† la taille du CNN
cv2.imwrite("panneau_detecte.jpg", roi)  # Sauvegarde pour test

#Extraction des zones d‚Äôint√©r√™t (ROI)
# Supposons que 'x, y, w, h' sont les coordonn√©es du panneau d√©tect√©
roi = image[y:y+h, x:x+w]  # Extraire la zone du panneau
roi = cv2.resize(roi, (64, 64))  # Adapter √† la taille du CNN
cv2.imwrite("panneau_detecte.jpg", roi)  # Sauvegarde pour test

#Cr√©ation du CNN pour la reconnaissance des panneaux
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
import cv2
import numpy as np

# Cr√©ation du mod√®le CNN
model = Sequential([
    Conv2D(32, (3,3), activation='relu', input_shape=(64, 64, 3)),
    MaxPooling2D(pool_size=(2,2)),
    Conv2D(64, (3,3), activation='relu'),
    MaxPooling2D(pool_size=(2,2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(4, activation='softmax')  # 4 classes : STOP, Danger, C√©dez le passage, Feux tricolores
])

# Compilation du mod√®le
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])


#Test du CNN sur un panneau d√©tect√©
# Charger l'image extraite
image_test = cv2.imread("panneau_detecte.jpg")
image_test = cv2.resize(image_test, (64, 64))
image_test = np.expand_dims(image_test, axis=0)  # Ajouter une dimension pour le mod√®le

# Pr√©diction avec le CNN
prediction = model.predict(image_test)
classes = ["STOP", "Danger", "C√©dez le passage", "Feux tricolores"]
panneau_detecte = classes[np.argmax(prediction)]  # Classe avec la meilleure probabilit√©

print("Panneau d√©tect√© :", panneau_detecte)
